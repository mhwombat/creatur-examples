We create a type to represent the |Bug| species.
Each bug has a unique ID, a colour, sex, an energy level,
and a sequence of genetic information.

\begin{code}
data Bug = Bug
  { 
    bugName :: String,
    bugColour :: BugColour,
    bugSex :: Sex,
    bugEnergy :: Int,
    bugGenome :: ([Bool],[Bool])
  } deriving (Show, Generic)

instance Serialize Bug
\end{code} 

We make |Bug| implement the |Agent| 
and |Record| classes.
Our bugs will stay alive until their energy reaches zero.

\begin{code}
instance Agent Bug where
  agentId = bugName
  isAlive bug = bugEnergy bug > 0

instance Record Bug where key = agentId
\end{code} 

We create the genes for colour and sex.

\begin{code}
data BugColour = Green | Purple deriving (Show, Eq, Generic)
instance Serialize BugColour

data Sex = Male | Female deriving (Show, Eq, Generic)
instance Serialize Sex

colourCode :: Code BugColour Bool
colourCode = mkGrayCode [Green, Purple]

sexCode :: Code Sex Bool
sexCode = mkGrayCode [Male, Female]
\end{code} 

Because our bugs will reproduce \emph{sexually}, there's an extra step for
determining their characteristics based on their genome,
a step that was not necessary for plants.
Agents that reproduce sexually have \emph{two} sets of genes, 
one inherited from each parent.
These genes may not be identical,
so we need a function that determines the resulting colour of the bug
from its genes.
Let's make green \emph{dominant}, and purple \emph{recessive}.
This means that a bug with one green gene will be green,
no matter what the other gene is.
The only way that a bug can be purple is if both colour genes are purple.

\begin{code}
instance PairedGene BugColour where
  express Green _       = Green
  express _ Green       = Green
  express Purple Purple = Purple
\end{code} 

We need a similar function that determines the actual sex of the bug.
A bug with two |Female| genes is female, a bug with at least one 
|Male| gene is male.
(This is loosely based on the XY-chromosome system used by
humans and some other animals.)

\begin{code}
instance PairedGene Sex where
  express Male _        = Male
  express _ Male        = Male
  express Female Female = Female
\end{code} 

To support reproduction, we need a way to build a bug from its genome.
If a mutation occurs, the resulting sequence of |Bool|s may not
be a valid code for a colour, in which case the call to |decodeNext|
will return |Nothing|.

All bugs start life with 10 units of energy.
        
\begin{code}
buildBug :: String -> ([Bool], [Bool]) -> Bug
buildBug name g = Bug name colour sex 10 g
  where (s, g') = decodeAndExpress sexCode g
        (c, _) = decodeAndExpress colourCode g'
        sex = fromMaybe Female s
        colour = fromMaybe Green c
\end{code} 

Next, we need a way to mate two bugs and produce some offspring.
We can do this by implementing the |Reproductive| class in 
\path{ALife.Creatur.Genetics.Reproduction.Sexual}.
This class requires us to implement the following:
\begin{enumerate}
\item A type called |Base|, which specifies the type used to encode
genes for this species. Recall that we've used |Bool|s for this purpose.
\item A method called |produceGamete| which shuffles (and maybe mutates)
the two sequences of genes from one parent, 
and then produces a \emph{single} sequence that will become part of the
child's genome.
(This is analogous to creating either a single sperm or ova.)
\item A method called |build| which creates the offspring.
We can use the |buildBug| method that we've already created,
but we need to wrap it in a |Maybe| to satisfy the type signature of
|build|.
\end {enumerate}

\begin{code}
instance Reproductive Bug where
  type Base Bug = Bool
  produceGamete a = 
    repeatWithProbability 0.1 randomCrossover (bugGenome a) >>=
    withProbability 0.01 randomCutAndSplice >>=
    withProbability 0.001 mutatePairedLists >>=
    randomOneOfPair
  build name g = Just $ buildBug name g
\end{code} 

Although the implementation of |produceGamete| is similar to that
of |recombine| for the |Plant| class, 
these two functions have different uses.
Asexual reproduction uses |recombine| to mix the genetic
information from two parents;
the resulting sequence becomes the entire genome of the child.
Sexual reproduction uses |produceGamete| to mix the genetic information
from \emph{one} parent;
the resulting sequence becomes \emph{half} of the genome of the child.
The other half of the child's genome comes from the other parent,
also generated using |produceGamete|.

|runBug| is invoked when it is the agent's turn to use the CPU.
It triggers mating.
Just being alive costs energy, so we take away one
unit of energy.

\begin{code}
runBug :: Bug -> StateT (SimpleUniverse Bug) IO Bug
runBug bug = do
  writeToLog $ 
    bugName bug ++ " just woke up. Energy=" ++ show (bugEnergy bug)
  bug2 <- maybeMate bug
  let bug3 = bug2{ bugEnergy = bugEnergy bug2 - 1}
  if isAlive bug3
    then
      writeToLog $ 
        bugName bug3 ++ " is going back to sleep. Energy=" 
          ++ show (bugEnergy bug3)
    else writeToLog $ bugName bug ++ " is dead"
  return bug3
\end{code} 

Let's let the females initiate mating.
If this bug is female,
another bug is randomly selected as a potential mate.

\begin{code}
maybeMate :: Bug -> StateT (SimpleUniverse Bug) IO Bug
maybeMate bug =
  if bugSex bug == Female
    then do
      xs <- agentIds
      let otherIds = filter (bugName bug /=) xs
      otherId <- fromList $ zip otherIds (repeat (1 % 1))
      writeToLog $ bugName bug ++ " sees " ++ otherId
      withAgent (tryToMate bug) otherId
      return bug
    else return bug
\end{code} 

If the potential mate is male, then mating occurs.

\begin{code}
tryToMate :: Bug -> Bug -> StateT (SimpleUniverse Bug) IO Bug
tryToMate bug otherBug =
  if bugSex otherBug == Male
    then do
      writeToLog $ bugName bug ++ " mated with " ++ bugName otherBug ++ "."
      name <- genName
      (Just baby) <- liftIO $ evalRandIO (makeOffspring bug otherBug name)
      writeToLog $ 
        bugName bug ++ " and " ++ bugName otherBug ++
          " gave birth to " ++ name ++ ", a " ++ 
          show (bugColour baby) ++ " " ++ show (bugSex baby) ++ " bug"
      addAgent baby
      return otherBug
    else do
      writeToLog $ 
        bugName bug ++ " is not interested in " ++ bugName otherBug
          ++ "."
      return otherBug
\end{code}

\includeSource{src/Tutorial/Example3/Bug.hs}

